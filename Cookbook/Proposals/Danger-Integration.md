# Introduce Danger

* Author: Olivier Halligon
* Review Manager: TBD

## Introduction

[Danger](https://danger.systems/ruby/) is a tool that is able to comment on your Pull Requests based on some rules that you can write yourself.

This proposal suggest that we adopt Danger to automatically check cases that we missed in the past during some PR reviews.

This proposal also present an initial rule where Danger will be useful for us. Note that we will add more rules in the future via separate proposals or discussions (see [Alternatives Considered](#alternatives-considered)); this proposal focuses only on the first integration.


## Motivation

We have seen some common mistakes happen multiple times in our past PRs, like:

 * `(null)` references in `pbxproj` files
 * snapshot files added in copy files phase in targets
 * forgetting to remove old snapshot files when renaming a test
 * forgetting to add a CHANGELOG when releasing the SDK

We are only human and some of those things are sometimes hard to spot (e.g. in diffs on `pbxproj`), which is why it's easy to miss those (and why it happened in the past), resulting in those errors or omissions ending up in `develop` by mistake.

By using a bot and a tool like Danger, we ensure that at least most of those hard-to-spot mistakes are detected by Danger, which will comment to warn us about it.

Danger can also improve our review experience by not only warning on issues it found in the code, but also inform us on the state of the PR. This would help us enforce etiquette for example if we want to:

 * motivate small PRs and avoid large PRs (which is actually the rule proposed below)
 * be sure everyone is on board when deciding to update or add a new pod
 * be sure the PR author has assigned itself to the PR


## Proposed solution

This proposal suggest to:

* Integrate Danger in our repository (i.e. add it to the `Gemfile` and configure the CI to run it as a job)
* Activate a first rule that would help solve one of the points listed above, namely warning about PR size
* Propose more rules in the future

### Presentation of Danger

_Before going further, it's good to know how Danger works to understand what it's capable or not capable of doing, and thus have ideas what features it can bring even in the future and what rules can or cannot be used for._

`danger` is a command line tool that is typically triggered as a script step by the CI, and has access to the PR metadata (including the PR title, author, labels, list of added/removed/modified files, etc).

Using a `Dangerfile` to write our custom rules, we are able to ask Danger to post back comments on the PR, depending on the conditions we want. We can make use of those PR metadata in those rules (for example post a comment only if this metadata X has a value matching Y), which gives Danger all its power.

Danger is able to post comments of type "plain markdown", "informative", "warning" and "failures". Comments of type "failure" make `danger` exit with a non-zero code, making the CI job fail on purpose.

For example we can write a rule which would post a comment if, inspecting the PR metadata, we see that the `CHANGELOG.md` file was not modified:

![Danger comment](https://danger.systems/images/danger-screenshot-074f084c.png)

This means that:

 - Danger will only trigger when the CI triggers. If we have rules that use the PR metadata to look at what labels are set on the PR for example, they will only consider the labels present at the time the CI job is run, and if those labels get updated, Danger will only see the new labels if the CI job is run again
 - Danger is more focused on rules that make use either of PR metadata (e.g. checking the title contains a JIRA ticket) or diff content (which files were changed, etc). It does not substitutes to a linter for example (but it can drive a linter like `swiftlint` and use the warnings generated by such linter to generate inline comments in the PR, to report those warnings inline)

Also note that if Danger is run multiple times on a PR – typically because the CI is triggered again after the author added more commits to the PR – it will *update* its comment if it already exists, to prevent spamming the PR with a new comment on every CI build.


### Integration of Danger in our CI

We propose to run the `danger` command line as a job:

* Only during the `test_pr` and `test_release` workflows, as there will be otherwise no pull request to make comments, but is still useful to have rules checking PRs from both feature and release branches
* Immediately after the `checkout_code` job – so that danger will have access to the code itself if needed – and in parallel with all other jobs (`test_*` and `build_*` jobs) in the workflows

⏱ Danger is quite fast, as all the information the rules are based on are the metadata fetched from the Pull Request or from the git diff, so it doesn't have to analyse your codebase (like a linter would do) – just to decode the JSON of the PR, run the `Dangerfile`, then call the GitHub API to post the PR comment. It's unlikely that integrating Danger will have any impact on the CI total time, especially if run in parallel of the `test_pr` jobs


### Initial Rule to activate

_As it won't be useful to integrate Danger in the repo without having any rule at all in the `Dangerfile` (as this would do nothing and thus would not solve any issue listed in the Motivation section), this proposal also suggests to implement one simple but useful rule during this initial Danger integration in our repo._

The first rule that we propose to activate, and one which can be easy to write, is one to warn about a Pull Request which exceeds the maximum number of changes

This simply consists of this code in the `Dangerfile`:

```ruby
warn("This PR is too big. Please split it in smaller PRs. If you can't split it, please justify why.") if git.lines_of_code > 800
```

This will make the bot generate a comment on the Pull Request with a ⚠️ emoji and the message above, only if the total number of lines added+removed in the diff is greater that our limit of 800 lines.

Being just a warning message, it will only be informative, and will not prevent the PR to build nor make the CI fail. This is to avoid being blocked if there is a justification in breaking that limit (e.g. big refactoring that can't be split)

### Additional rules in the future

We already have [some ideas for additional rules](#picking-a-different-first-rule) to add to Danger that would solve some of the other issues mentioned in the [Motivation](#motivation) section.

Those rules are not part of this current proposal, in order to focus discussions on integration and initial rule. We will propose those potential future rules via separate proposals.

## Impact on existing codebase

This tool won't have any impact on the codebase at all.

It will only have an impact on our review process: we will now be informed by Danger when a PR is bigger than normal, and will be able to decide to reject that PR for being too big (or accept that it's an acceptable exception if that's justified)

## Alternatives considered

### Using Danger Swift

Danger has recently gained a Swift version as an alternative to the Ruby version. This could make it easier to write `Dangerfile` for people more familiar to Swift than Ruby, so it's an alternative worth considering.

* Danger-Swift [relies on interacting with the DangerJS](https://danger.systems/swift/tutorials/architecture.html#setup) to do its job.
* Danger-Swift is installed via SPM (though it uses a workaround of having to bind it with a Swift target and a Swift file with only Foundation as dependency), so it needs another layer of caching in our CI, to be able to cache SPM build artefacts and dependencies when running `swift build` to install it on each CI run (while the Ruby version can rely on our existing caching of bundler gems)

* Also note that the `Dangerfile.swift` will be more verbose than the Ruby `Dangerfile`. For example, the one-liner PR size rule mentioned in this proposal would become:

```swift
import Danger
let danger = Danger()

let bigPRThreshold = 800
if (danger.github.pullRequest.additions + danger.github.pullRequest.deletions > bigPRThreshold) {
  warn('> This PR is too big. Please split it in smaller PRs. If you can't split it, please justify why.')
}
```

* As Orta points out in the "Help me choose" page, Danger Swift also has some limitations compared to Danger Ruby:

> You may notice that there was a Swift logo in the index page, Swift is the first language supported by Danger JS’s process environment. Once a new language has been built out, and is stable, then I’ll be building out some documentation in this site.

And in the documentation of Danger Swift's Troubleshooting section:

> *I had a Ruby plugin which did x and y*
> Yeah… Maybe I’ll just point you at the “Making a Plugin” guide. There’s also a discovery problem because there’s no central index, once there are a few plugins we can make an index on this site. If it gets bit and polished enough, then I think it might be reasonable to move into Danger Swift too.

---

On a side note, it's easy enough to test your Dangerfile for errors, by locally running in your terminal either `bundle exec danger pr <url-of-pr-to-test>` for a Ruby Dangerfile or `swift run danger-swift pr <url-of-pr-to-test>` for a Swift Dangerfile. So avoiding syntax errors and doing iteration testing bring similar experience in both worlds.

In the end it's mainly a matter of tradeoff, the familiarity of the Swift language vs the additional cache step, dependencies, and the risk of plugins and documentation shortage (compare the [Danger-Swift documentation](https://danger.systems/swift/) and [DSL reference](https://danger.systems/swift/reference.html) to its more mature [Ruby counterpart](https://danger.systems/ruby/) and [DSL reference](https://danger.systems/reference.html) to get an idea of each project's doc maturity)

### Integration in the CI

We could potentially trigger the `danger` CLI earlier in the CI workflow, to be notified about anything we missed ASAP in the PR. But this brings the risk of not having access to the code (if we do that before the checkout step), requiring us to fetch the `Dangerfile` via the GitHub API in order for it to be present to run `danger`, and limiting our possibilties at what rule we can write in the future (and to be honest I'm not even sure every feature of Danger would work if we haven't checked out the code yet)

Another alternative to trigger it earlier would be to run it during the `checkout_code_steps`, right after the `save_gems_cache` step, to run Danger right after its installation by `bundle install` in this job. This would allow to avoid waiting for things like the CocoaPods cache restoration and the `persist_workspace` steps, which could take a significant time to run. One drawback of this approach is that it means that `danger` would be run for every workflow using this `checkout_code` job (so basically all workflows, including the ones where no PR is associated, making `danger` fail on those), instead of only triggering on `test_pr` and `test_release` workflows.

We could also decide to trigger `danger` later, for example _after_ the `test_babylon` job. This would give the advantage of allowing Danger to have access to test results for example. Which means that in the future we could use Danger to post a comment in the PR to tell which test failed or post the link to the HTML report maybe. But following that logic we should also trigger `danger` after `test_telus` and other jobs running tests, which will likely report some test failures multiple times (one per job if the failure is common to those targets). Which brings other questions and complexities into consideration (like does that mean one Danger comment on the PR... per test job, in each PR? Or a dedicated job after everything synchronizing all the previous test jobs but having to wait on them all before being able to report?) that might be too early to discuss for this initial proposal.

We thus think that those potential future rules based on test results are not our top priorities for now and it's too early to decide to move Danger so late in the build pipeline, as it would mean only having feedback fron Danger _after_ the `test_pr` job has finished – which is usually one of the last to finish on PRs. It's totally imaginable to propose moving the `danger` step after a test job in a later PR if it becomes a limitation for a rule we want to implement in the future, but such a change would require a dedicated proposal to discuss the aforementioned consequences (especially having multiple jobs running in parallel and sync of the `danger` instances).

On a side note, it is worth reminding the reader that Danger only posts one comment (after the initial run of the CI) and then _updates_ said comment on subsequent runs; which means that even if you commented or watched the PR, you won't be spammed by GitHub notifications, as comment _updates_ don't trigger notifications on GitHub.

### Picking a different first rule

There are other ideas for initial rules to include in our `Dangerfile`, including but not limiting to:

* Analyse the `pbxproj` files to find missing references and potential `(null)` values and warn about them
* Analyse the `pbxproj` files to detect any files that was added to a target but is typically one to exclude from the final bundle – examples including `Info.plist` files but also `Snapshot` files
* Generate an informative comment if any of the build config changed in a project, so that reviewers would not miss those changes in a hard-to-read pbxproj diff
* Generate an informative comment if the `Podfile.lock` changed, so that reviewers take extra care when pods are added, removed or updated on the project
* Warn if the `CHANGELOG.md` hasn't been updated, and/or enforcing updating the SDK changelog if there was any change in `SDK/*`
* Warn if the PR doesn't have the author assigned to it
* Report SwiftLint warnings in the PR (though it would require to move the execution of Danger after the `test_pr` job, and besides, as of today those SwiftLint violations are reported as errors anyway)
* ...

Those rules could also have been picked as initial candidate for the first rule we implement in Danger, but the rule about the PR size seems more straitforward to implement as a good way to test the initial usage of Danger on our process.

All the rules mentionned in the list above will get their own separate proposal, so that we can discuss their benefits, the exact conditions to trigger each rule, and alternatives considered for each of them separately.

_Note: I am hoping to write proposals for some of those additional rules soon, so that we could discuss them altogether in the upcoming proposal meeting alongside this very proposal for Danger, if time allows. I'll update the list above with links as I publish those other proposals_

### Different conditions for PR size Rule

The rule propose to make the condition based on the "overall lines of code added/removed in the diff" (that's the value returned by `git.lines_of_code` as documented in Danger docs). Which means it checks the value of `insertions` + `deletions`. That means that a PR which adds 20 lines and remove 30 lines will be seen as a size of 50.

We could instead pick one of these other alternatives:

* Define the size of a PR by `abs(insertions - deletions)`, so that a PR adding 30 lines and removing 20 will be seen as of size 10. But since there's no guarantee that those 30 lines added are _replacing_ the 20 lines removed, as they could also be completely unrelated, we don't think it is a reliable metric

* Use a ponderation of `A * insertions + B * deletions`, typically with `A > B > 0`, arguing that it's faster to review deleted code than added code. I'm not convinced that it's really the case – or worth going to such detail – but we might consider trying it in a future PR if we see that Danger warns too often about false positives

* Ignore some files when computing the PR size, considering they don't play a significant role in estimating the PR _review time and complexity_. Here are some file types that we might consider ignoring when computing `insertions` and `deletions`: Snapshot files, Localization files, Assets (like images), ...

* Use `max(insertions, deletions) < 800` to consider the limit not on the sum of both metrics, but on either of these metrics separately (which is how some team members have interpreted our current informal limit so far, so it's worth clarifying if the limit is on the total or the max anyway).

It still has the downside that for example fixing the indentation of a 50-lines block of code will count for 100 (50 deletions + 50 insertions), but this kind of special case is hard to differentiate from a real deletion of 50 lines in one place and addition of 50 lines in another. That's also why the rule is only a _warning_ emited by Danger – just for information for the PR author and reviewers – and won't fail the CI or block the merge in case of false positives.

### Making the rule violation fail the build

This would mean that any PR with more than 800 additions+deletions will never compile and thus won't be mergeable (note that Danger can only post comments and make its CI job succeed or fail, it cannot close a PR for example).

Given the fact that the metric for PR size is not perfect (e.g. just the full re-indentation of a 500-lines file can lead to a PR size of 1000 while it has no real complexity for review) and can lead to false-positives (number of lines of code != PR complexity), and that some PRs can't be split in smaller ones (e.g. big refactoring) and in those cases big PRs are unavoidable, we don't think it would be wise to make that rule fail the CI and prevent the merge in all cases. The comment posted by Danger on the PR should be enough to let the author either realise that their PR is too big, or comment back to justify why they can't split it.

### No action

The last alternative would be to not integrate Danger at all in the project. When considering that alternative, keep in mind though that this proposal is not only for the PR size rule but as an introduction for future proposals for other rules to come. (i.e. rejecting this proposal completely and taking no action would mean that we decide that we don't want Danger at all in the repository, as opposed to accepting Danger but considering a different first rule)
