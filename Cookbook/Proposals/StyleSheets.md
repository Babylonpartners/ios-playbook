# Composable value-type style sheets

* Author(s): Anders Ha
* Review Manager: Sergey Shulga, David Rodrigues

## Problem Statement
The Style Sheet approach is built upon class inheritance. For example, one defines a style sheet for `CustomView` by:

```swift
class CustomViewStyleSheet: ViewStyleSheet<CustomView> {
    var customAttribute: CGFloat = 0.0

    override func apply(to view: CustomView) {
        super.apply(to: view)
        view.customAttribute = customAttribute
    }
}
```

It is unfortunately not ideal in three areas:

1. Ease of use: Need of redeclaring all styleable properties.

    As shown in the example above, for `customAttribute` to be applicable via a style sheet, it has to be redeclared asa stored property in the style sheet. This creates boilerplate that needs to be manually kept in sync, or code-generated by third party tools, as the complexity of view grows.

2. Type safety: Not playing well with hierarchies of view class. 

    A style sheet for a open class must be declared with a generic view parameter.

    ```swift
    class CustomView: UIView {
        var customAttribute: CGFloat = 0.0
    }
    final class BetterView: CustomView {
        var betterAttribute: CGFloat = 0.0
    }

    class CustomViewStyleSheet<View: CustomView>: ViewStyleSheet<View> {
        var customAttribute: CGFloat = 0.0

        override func apply(to view: CustomView) {
            super.apply(to: view)
            view.customAttribute = customAttribute
        } 
    }

    class BetterViewStyleSheet: CustomViewStyleSheet<BetterView> {
        var betterAttribute: CGFloat = 0.0

        override func apply(to view: BetterView) {
            super.apply(to: view)
            view.betterAttribute = betterAttribute
        }
    }
    ```

    The primary reason is to maintain the type safety of the `apply(to:)` method declaration. Imagine a non-generic implementation of `CustomViewStyleSheet`:

    ```swift
    class CustomViewStyleSheet: ViewStyleSheet<CustomView> {
        var customAttribute: CGFloat = 0.0

        override func apply(to view: CustomView) {
            super.apply(to: view)
            view.customAttribute = customAttribute
        }
    }
    ```

    Now when one tries to subclass `CustomViewStyleSheet` to produce a specialized style sheet for `BetterView`, this happens:

    ```swift
    class BetterViewStyleSheet: ViewStyleSheet<CustomView> {
        var customAttribute: CGFloat = 0.0

        func apply(to view: BetterView) {
            /** ‚ö†Ô∏è Not the same declaration as `apply(to:)` below. Ô∏èÔ∏èÔ∏è‚ö†Ô∏è **/
            self.apply(to: view as CustomView)
        }

        override func apply(to view: CustomView) {
            /** This precondition would pass. **/
            precondition(view is BetterView)

            super.apply(to: view)

            /** üî¥ COMPILER ERROR: `view` does not have any property `betterAttribute`.
                This is because `view`, at compile time, is not the same type as `self`. **/
            view.betterAttribute = betterAttribute
        }
    }
    ```

    This is _probably_ fine in a concrete context, because when calling `styleSheet.apply(to:)`, the most specific overload takes precedence, and in this case the one accepting `BetterView` would be called when being used with `BetterView`. Unintentionally, it also means that the style sheet for `BetterView` can be used with any `CustomView`.

    But in a generic context, recall that the base style sheet class `ViewStyleSheet<View: UIView>` conforms to `StyleSheetProtocol`:

    ```swift
    public protocol StyleSheetProtocol {
        associatedtype View

        func apply(to view: View)
    }

    open class ViewStyleSheet<View: UIView>: StyleSheetProtocol {
        /* ... */

        /* Swift compiler infers from this declaration that associatedtype View should be bound to
           the generic parameter View.  */
        open func apply(to view: View) {
            /* ... */
        }
    }
    ```

    The associatedtype `View` of the `StyleSheetProtocol` conformance is bound to the generic parameter `View` **and** that particular `apply(to:)` declaration. It is what Swift compiler writes to the protocol witness table, and uses for dispatching. In other words, if `BetterViewStyleSheet` does not override the same declaration but only overload it, the overload **would not** be invoked in a generic environment constrained to `StyleSheetProtocol`, even if it is named the same.

    So to have type safety in all scenarios, we need to make sure style sheets for open view classes are generic. These however are awkward at use sites, since you would have to repeat the type name again. For example:

    ```swift
    /** Ouch! Have to repeat the type just because `CustomView` is open. **/
    let styleSheet0 = CustomViewStyleSheet<CustomView>()
    let styleSheet1 = CustomViewStyleSheet<BetterView>()
    let styleSheet2 = BetterViewStyleSheet()
    ```

3. Correctness: Unintended Sharing

    Style sheets are currently classes due to the use of inheritance. This makes them prone to the classic problem of unintended sharing. There is also a perception of style sheets being a value model, which makes it less intuitive to dodge bugs in this regard.

    Imagine you have created a Node with a style sheet applied:

    ```swift
    let styleSheet = CustomViewStyleSheet()
        .compose(\.customAttribute, 123.0)

    let first = CustomComponent(styleSheet: styleSheet)
    ```

    If now you create another component by reusing the same style sheet:

    ```swift      
    let second = CustomComponent(
        styleSheet: styleSheet
            .compose(\.customAttribute, 789.0)
    )
    ```

    Guess what would the applied `customAttribute` be, when both go on screen? It would be `789.0` for both, because the style sheet is a reference type, and the second `compose(_:_:)` changes the same instance that is used by the formerly created component. :)

    What a headache, right?


## Identified Requirements

1. The approach must be applicable to reusable views.

    When multiple style sheets with symmetrical differences are applied in a row in any order, the reused view would not end up in an indeterministic state.

1. The approach must be compatible with view subclassing.

1. The approach should address unintended sharing if possible.

## Proposed Solution

A new value type `StyleSheet<View>` shall be introduced, with the following features:

1. Copy on write & value semantics: Backed by CoW `Dictionary`. Support `Equatable` out of the box.

2. Built around Key Paths introduced since Swift 4, and has proper support of entries setting key paths that are partially overlapping with each other.

3. Support producing **snapshots** for change reversion to enable deterministic view reuse.

    Before applying a stylesheet, a snapshot of all affected key paths is taken, and is returned to the callee after the application. It is up to the callee whether to and when to apply the snapshot for change reversal.

    In the case of a reusable view/cell, the expectation is that the view would store the inverse/snapshot & apply it as part of the cleanup e.g. in `prepareForReuse()`.
    
    This eliminates the state indeterminism of closure-based styling approaches, while not requiring any default value to be declared upfront like how our `StyleSheet` framework currently does. 

4. Can be used for any view and any arbitrary subclass without type declaration.

### Implementation Plan

1. As soon as the new `StyleSheet` type is available in Bento, new components shall start using it.

2. A conveinent extension to `UIView` that accepts style sheets, and stores the snapshot automatically for reverting changes later on. For example:

   ```swift
    extension UIView {
        private var snapshotForReverting: StyleSheet<Self>? {
            /** Automagical storage for one style sheet snapshot. Probably ObjC associated objects. **/
        }

        public func apply(_ styleSheet: StyleSheet<Self>) {
            /** Revert old snapshots **/
            snapshotForReverting?.apply(to: self)
            /** Apply the new one **/
            let snapshot = styleSheet.apply(to: self)
            snapshotForReverting = snapshot
        }
    }

   view.backgroundColor = .green
   view.clipsToBound = false

    // The mechanism takes a snapshot of all affected key paths as it applies the new value
    // one after another. The snapshot then creates a snapshot as `StyleSheet<Self>`, which
    // can be applied to revert the view back to its original state.
   view.apply(
       StyleSheet()
            .setting(\.backgroundColor, .red)
            .setting(\.clipsToBound, true)
    )
   expect(view.backgroundColor) == .red
   expect(view.clipsToBound) == true

    // The stored snapshot is applied before the new style sheet is applied.
    // So `clipsToBound` would be reverted to the original value.
   view.apply(
       StyleSheet()
            .setting(\.backgroundColor, .blue)
    )

   expect(view.backgroundColor) == .blue
   expect(view.clipsToBound) == false
   ```

3. BentoKit components shall be gradually migrated as soon as possible, potentially in batches to limit source breakage. Existing components may continue to use their existing style sheet types until author wishes to migrate.

### Potential Issues
#### Support only mutable properties.
Not all stying parameters are exposed as instance properties.

`UIButton` is the most apparent example. We could mitigate this by providing extensions with computed properties of `[UIControl.State: U]`.

#### Might require use of protocols to limit exposed surface.
If there are properties, inherited from a parent view class, that should be hidden on the component root view, one might need to declare a protocol with all whitelisted properties.

```swift
protocol SpecialButtonProtocol {
    var layoutMargins: UIEdgeInsets { get set }
}

extension UIButton: SpecialButtonProtocol {}

// EXAMPLE: We hide all properties except for `layoutMargins`.
let styleSheet: StyleSheet<SpecialButtonProtocol>

var button = UIButton()
styleSheet.apply(to: &button)
```

## Impact on existing APIs
The value type `StyleSheet` is an additive change alone.

With us gradually migrating to Design Library components and having atomic components to back them, the source breaking change could be contained with the Design Library.

We can keep existing BentoKit components and style sheets, until we are ready to replace them with the atomic component based approach.

## Alternatives considered
### Status Quo
We can continue to use the existing solution, redeclaring all customizable parameters, writing the manual code to apply them, and continuing to avoid unintended sharing of style sheet instances at best effort.

### Code Generation
Code generation is an equally viable solution, in the sense that style sheets would become partially synthezied value types which resolves unintended sharing, whereas inhertiance is replaced by annotations. However, as part of an infrastructual solution, requiring build-time integration beyond linkage, need of learning Bento specific code-gen configurations and the maintenance might not be appealling to the general crowd.