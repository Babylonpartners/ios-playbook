## SwiftGen

[SwiftGen](https://github.com/SwiftGen/SwiftGen) allows plenty of possibilities to automatically generate code based on resources we store in our project. Following sections will describe which types of resources are currently integrated with SwiftGen and how to use them.

### Image assets

Using icons and images with our SwiftGen integration is really easy. The only thing you have to do is to add the image to `BabylonDesignLibrary/DesignLibrary/Assets.xcassets` and then you can just use it by calling `appearance.tokens.icons.image(.myNewIcon)`. Before compilation of `BabylonDesignLibrary`, SwiftGen is executed and regenerates the identifiers.
If you name your icon with camel case style (e.g. `MyNewIcon`), the same name will be generated. If you choose snake case style (e.g. `my_new_icon`), SwiftGen will generate a camel-cased identifier from it (e.g. `myNewIcon`).

#### Overriding icons in white label apps

Providing icon overrides for specific white label apps is as simple as adding the app-specific icon into the app's own asset catalog. Those will by default automatically take precedence over any icon with the same name from the DesignLibrary.

It works thanks to the way we customised the method generated by SwiftGen to access UIImages:
```
public static func image(_ name: Name) -> UIImage {
	return image(name, bundle: .main) 
}

public static func image(_ name: Name, bundle: Bundle) -> UIImage {
	let iconsBundle = Bundle(for: IconsBundleToken.self)
	guard let result = UIImage(named: name.rawValue, in: bundle, compatibleWith: nil)
		?? UIImage(named: name.rawValue, in: iconsBundle, compatibleWith: nil) else {
		 fatalError("Unable to load image named \(name).") 
	}
	return result
}
```
The method without specifying bundle automatically chooses `Bundle.main`. The algorithm is the following:
1. The method checks if the icon is present in the assets catalog of the main bundle. In most cases it will be the white label app bundle (this allows overriding the icon for specific app).
2. If the icon is not in the specified bundle, it will then fallback to pick the one from DesignLibrary assets catalog.
3. If both fails, `fatalError` is called; but this situation is impossible because SwiftGen creates identifiers based on the content of the DesignLibrary's assets catalog, so the the image has to at least be there (and if icon is deleted SwiftGen will remove that identifier for the generated file).

When an app overrides an icon with the same name in its assets catalog but you would still like to use the icon from DesignLibrary in some cases, you can explicitly pass `DesignLibrary.bundle` to enforce that the image is loaded from the DesignLibrary assets catalog.
